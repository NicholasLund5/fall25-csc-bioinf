"""
Bio.motifs.matrix Test Suite - Codon Implementation

Comprehensive test suite for sequence motif matrix implementations ported from BioPython 
to Codon, a high-performance Python compiler for computational biology.

Codon Adaptations Made:
- Replaced Python unittest framework with custom assertion functions
- Used @test decorators instead of unittest.TestCase methods
- Simplified exception handling (removed specific exception type checking)
- Used literal tolerance values instead of 10**(-places) expressions
- Replaced complex list comprehensions with explicit loops where needed
- Added explicit type handling for cross-language compatibility
- Maintained BioPython API compatibility while optimizing for Codon's static compilation

Classes Tested:
- GenericPositionMatrix: Base matrix with consensus/anticonsensus calculation, GC analysis
- FrequencyPositionMatrix: Count matrices with normalization and pseudocount handling  
- PositionWeightMatrix: Probability matrices with log-odds conversion
- PositionSpecificScoringMatrix: Scoring matrices with sequence analysis and motif comparison

Test Coverage:
- Matrix operations (indexing, iteration, string representation)
- Consensus sequence calculations (standard, anti-, degenerate)
- Normalization strategies with various pseudocount methods
- Log-odds conversion with custom background frequencies
- Sequence scoring and motif matching algorithms
- Statistical analysis (mean, std, Pearson correlation)
- Edge cases (empty matrices, extreme values, NaN/infinity)
- Integration testing of complete count→probability→scoring pipeline

40+ test cases validate Codon-compiled motif analysis functionality for high-performance
computational biology applications.
"""

import math
from python import numpy as np

# Import our motif modules (assuming they're in the same directory)
from matrix import GenericPositionMatrix, FrequencyPositionMatrix, PositionWeightMatrix, PositionSpecificScoringMatrix, Seq

# Helper functions for testing (replacing unittest assertions)
def assertEqual(a, b, msg=""):
    if msg:
        assert a == b, msg + ": " + str(a) + " != " + str(b)
    else:
        assert a == b, "Expected " + str(a) + " == " + str(b)

def assertAlmostEqual(a, b, places=7, msg=""):
    tolerance = 1e-7  # Use literal instead of 10**(-places)
    
    # Handle NaN values
    if math.isnan(a) and math.isnan(b):
        return  # Both NaN is considered equal
    elif math.isnan(a) or math.isnan(b):
        if msg:
            assert False, msg + ": One value is NaN: " + str(a) + " vs " + str(b)
        else:
            assert False, "One value is NaN: " + str(a) + " vs " + str(b)
    
    diff = abs(a - b)
    if msg:
        assert diff <= tolerance, msg + ": |" + str(a) + " - " + str(b) + "| = " + str(diff) + " > " + str(tolerance)
    else:
        assert diff <= tolerance, "|" + str(a) + " - " + str(b) + "| = " + str(diff) + " > " + str(tolerance)
        
def assertRaises(exception_type, func, *args, **kwargs):
    """Check that calling func(*args, **kwargs) raises exception_type"""
    try:
        result = func(*args, **kwargs)
        assert False, "Expected " + str(exception_type.__name__) + " to be raised"
    except Exception as e:
        # Check if it's the right exception type by name since isinstance might not work
        if exception_type.__name__ in str(type(e)):
            pass  # This is what we expected
        else:
            assert False, "Expected " + str(exception_type.__name__) + " but got " + str(type(e))

def assertTrue(condition, msg=""):
    if msg:
        assert condition, msg
    else:
        assert condition

def assertFalse(condition, msg=""):
    if msg:
        assert not condition, msg
    else:
        assert not condition

def assertIn(item, container, msg=""):
    if msg:
        assert item in container, msg
    else:
        assert item in container, str(item) + " not found in " + str(container)

# Test data
TEST_ALPHABET = "ACGT"
TEST_VALUES = {
    "A": [0.7, 0.0, 0.0, 0.9, 0.9, 0.9, 0.1, 0.1, 0.1, 0.1, 0.3, 0.0],
    "C": [0.2, 0.9, 0.0, 0.1, 0.0, 0.0, 0.4, 0.1, 0.8, 0.2, 0.0, 0.6],
    "G": [0.1, 0.1, 1.0, 0.0, 0.1, 0.0, 0.5, 0.8, 0.1, 0.7, 0.7, 0.4],
    "T": [0.0, 0.0, 0.0, 0.0, 0.0, 0.1, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
}

# ============================================================================
# GenericPositionMatrix Tests
# ============================================================================

@test
def test_generic_position_matrix_init():
    """Test GenericPositionMatrix initialization"""
    gpm = GenericPositionMatrix(TEST_ALPHABET, TEST_VALUES)
    assertEqual(gpm.alphabet, TEST_ALPHABET)
    assertEqual(gpm.length, 12)
    
    # Test values are properly stored and converted to float
    for letter in TEST_ALPHABET:
        assertEqual(len(gpm.data[letter]), 12)
        for i in range(12):
            assertAlmostEqual(gpm.data[letter][i], TEST_VALUES[letter][i])

@test
def test_generic_position_matrix_inconsistent_lengths():
    """Test that inconsistent lengths raise an exception"""
    bad_values = {
        "A": [0.7, 0.0, 0.0],
        "C": [0.2, 0.9],  # Different length
        "G": [0.1, 0.1, 1.0],
        "T": [0.0, 0.0, 0.0]
    }
    
    try:
        GenericPositionMatrix(TEST_ALPHABET, bad_values)
        assert False, "Expected Exception to be raised"
    except Exception:
        pass

@test
def test_generic_position_matrix_str():
    """Test string representation"""
    gpm = GenericPositionMatrix(TEST_ALPHABET, TEST_VALUES)
    str_repr = str(gpm)
    
    # Check that all letters are in the string representation
    for letter in TEST_ALPHABET:
        assertIn(letter, str_repr)
    
    # Check that position indices are included
    assertIn("0", str_repr)
    assertIn("11", str_repr)

@test
def test_generic_position_matrix_getitem():
    """Test indexing operations"""
    gpm = GenericPositionMatrix(TEST_ALPHABET, TEST_VALUES)
    
    # Test single letter access
    assertEqual(len(gpm["A"]), 12)
    assertAlmostEqual(gpm["A"][0], 0.7)
    
    # Test position access
    assertAlmostEqual(gpm["A"][5], 0.9)
    
    # Test tuple indexing (letter, position)
    assertAlmostEqual(gpm["A", 0], 0.7)
    assertAlmostEqual(gpm["C", 1], 0.9)
    
    # Test integer indexing for letters
    assertAlmostEqual(gpm[0][0], 0.7)  # A is first in alphabet

@test
def test_generic_position_matrix_setitem():
    """Test setting values"""
    gpm = GenericPositionMatrix(TEST_ALPHABET, TEST_VALUES)
    new_values = [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0]
    gpm["A"] = new_values
    assertEqual(gpm["A"], new_values)

@test
def test_generic_position_matrix_keys():
    """Test keys method"""
    gpm = GenericPositionMatrix(TEST_ALPHABET, TEST_VALUES)
    keys = list(gpm.keys())
    for letter in TEST_ALPHABET:
        assertIn(letter, keys)

@test
def test_generic_position_matrix_consensus():
    """Test consensus sequence calculation"""
    gpm = GenericPositionMatrix(TEST_ALPHABET, TEST_VALUES)
    consensus = gpm.consensus
    
    # Based on TEST_VALUES, expected consensus should be:
    # Position 0: A (0.7) > C (0.2) > G (0.1) > T (0.0) → A
    # Position 1: C (0.9) > G (0.1) > A (0.0) = T (0.0) → C
    # Position 2: G (1.0) > others (0.0) → G
    expected_start = "ACG"  # First 3 positions based on max values
    assertEqual(str(consensus)[:3], expected_start)

@test
def test_generic_position_matrix_anticonsensus():
    """Test anticonsensus sequence calculation"""
    gpm = GenericPositionMatrix(TEST_ALPHABET, TEST_VALUES)
    anticonsensus = gpm.anticonsensus
    
    # Anticonsensus should pick minimum values at each position
    # Position 0: T (0.0) is minimum → T
    # Position 1: A (0.0) = T (0.0), but we'll get the first one found
    expected_start = "T"  # At least first position should be T
    assertEqual(str(anticonsensus)[0], expected_start)

@test
def test_generic_position_matrix_degenerate_consensus():
    """Test degenerate consensus sequence calculation"""
    # Create a specific test case for degenerate consensus
    deg_values = {
        "A": [8.0, 1.0, 5.0, 0.0],  # Strong A, weak A, moderate A, no A
        "C": [1.0, 8.0, 4.0, 0.0],  # Weak C, strong C, moderate C, no C  
        "G": [1.0, 1.0, 1.0, 0.0],  # Weak G, weak G, weak G, no G
        "T": [0.0, 0.0, 0.0, 10.0]  # No T, no T, no T, strong T
    }
    
    gpm = GenericPositionMatrix(TEST_ALPHABET, deg_values)
    degenerate = gpm.degenerate_consensus
    
    # Position 0: A=8, C=1, G=1, T=0 → A dominates → A
    # Position 1: A=1, C=8, G=1, T=0 → C dominates → C  
    # Position 2: A=5, C=4, G=1, T=0 → A and C are close → should be M (AC)
    # Position 3: A=0, C=0, G=0, T=10 → T dominates → T
    
    result = str(degenerate)
    assertEqual(result[0], "A")
    assertEqual(result[1], "C") 
    assertEqual(result[3], "T")
    # Position 2 might be M or one of A/C depending on exact logic

@test
def test_generic_position_matrix_calculate_consensus():
    """Test calculate_consensus method"""
    gpm = GenericPositionMatrix(TEST_ALPHABET, TEST_VALUES)
    consensus = gpm.calculate_consensus()
    
    # Should return a string, not a Seq object
    assertTrue(isinstance(consensus, str))
    assertEqual(len(consensus), gpm.length)

@test
def test_generic_position_matrix_gc_content():
    """Test GC content calculation"""
    gpm = GenericPositionMatrix(TEST_ALPHABET, TEST_VALUES)
    gc_content = gpm.gc_content
    
    # Calculate expected GC content manually
    total_gc = sum(TEST_VALUES["G"]) + sum(TEST_VALUES["C"])
    total_all = 0.0
    for letter in TEST_ALPHABET:
        total_all += sum(TEST_VALUES[letter])
    expected_gc = total_gc / total_all
    
    assertAlmostEqual(gc_content, expected_gc)

@test
def test_reverse_complement():
    """Test reverse complement calculation"""
    counts = {
        "A": [8.0, 1.0, 2.0, 0.0],
        "C": [1.0, 2.0, 1.0, 1.0],
        "G": [1.0, 8.0, 7.0, 2.0],
        "T": [0.0, 1.0, 0.0, 9.0]
    }
    
    gpm = GenericPositionMatrix(TEST_ALPHABET, counts)
    rc_gpm = gpm.reverse_complement()
    
    # Reverse complement should swap A<->T, C<->G and reverse positions
    # Original: A=[8,1,2,0], T=[0,1,0,9]
    # RC: A should be reverse of original T = [9,0,1,0]
    assertEqual(rc_gpm["A"], [9.0, 0.0, 1.0, 0.0])
    assertEqual(rc_gpm["T"], [0.0, 2.0, 1.0, 8.0])
    assertEqual(rc_gpm["G"], [1.0, 1.0, 2.0, 1.0])  # Reverse of original C
    assertEqual(rc_gpm["C"], [2.0, 7.0, 8.0, 1.0])  # Reverse of original G

# ============================================================================
# FrequencyPositionMatrix Tests
# ============================================================================

@test
def test_frequency_position_matrix():
    """Test FrequencyPositionMatrix functionality"""
    # Use integer counts for frequency matrix
    counts = {
        "A": [7.0, 0.0, 0.0, 9.0, 9.0, 9.0, 1.0, 1.0, 1.0, 1.0, 3.0, 0.0],
        "C": [2.0, 9.0, 0.0, 1.0, 0.0, 0.0, 4.0, 1.0, 8.0, 2.0, 0.0, 6.0],
        "G": [1.0, 1.0, 10.0, 0.0, 1.0, 0.0, 5.0, 8.0, 1.0, 7.0, 7.0, 4.0],
        "T": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
    }
    
    fpm = FrequencyPositionMatrix(TEST_ALPHABET, counts)
    assertEqual(fpm.alphabet, TEST_ALPHABET)
    assertEqual(fpm.length, 12)

@test
def test_frequency_position_matrix_normalize():
    """Test normalization to position weight matrix"""
    counts = {
        "A": [7.0, 0.0, 0.0, 9.0],
        "C": [2.0, 9.0, 0.0, 1.0],
        "G": [1.0, 1.0, 10.0, 0.0],
        "T": [0.0, 0.0, 0.0, 0.0]
    }
    
    fpm = FrequencyPositionMatrix(TEST_ALPHABET, counts)
    pwm = fpm.normalize()
    
    # Check that it returns a PositionWeightMatrix
    assertTrue(isinstance(pwm, PositionWeightMatrix))
    
    # Check that probabilities sum to 1 at each position
    for i in range(4):
        total = sum(pwm[letter][i] for letter in TEST_ALPHABET)
        assertAlmostEqual(total, 1.0)
    
    # Check specific probability calculation
    # Position 0: A=7, C=2, G=1, T=0, total=10
    assertAlmostEqual(pwm["A"][0], 0.7)
    assertAlmostEqual(pwm["C"][0], 0.2)
    assertAlmostEqual(pwm["G"][0], 0.1)
    assertAlmostEqual(pwm["T"][0], 0.0)

@test
def test_frequency_position_matrix_normalize_with_pseudocounts():
    """Test normalization with pseudocounts"""
    counts = {
        "A": [7.0, 0.0, 0.0, 9.0],
        "C": [2.0, 9.0, 0.0, 1.0],
        "G": [1.0, 1.0, 10.0, 0.0],
        "T": [0.0, 0.0, 0.0, 0.0]
    }
    
    fpm = FrequencyPositionMatrix(TEST_ALPHABET, counts)
    pwm = fpm.normalize(pseudocounts=1.0)
    
    # With pseudocounts=1.0, each count is increased by 1
    # Position 0: A=8, C=3, G=2, T=1, total=14
    assertAlmostEqual(pwm["A"][0], 8.0/14.0)
    assertAlmostEqual(pwm["C"][0], 3.0/14.0)
    assertAlmostEqual(pwm["G"][0], 2.0/14.0)
    assertAlmostEqual(pwm["T"][0], 1.0/14.0)

@test
def test_frequency_position_matrix_normalize_with_dict_pseudocounts():
    """Test normalization with dictionary pseudocounts"""
    counts = {
        "A": [7.0, 0.0],
        "C": [2.0, 9.0],
        "G": [1.0, 1.0],
        "T": [0.0, 0.0]
    }
    
    pseudocounts = {"A": 0.5, "C": 0.5, "G": 0.5, "T": 0.5}
    
    fpm = FrequencyPositionMatrix(TEST_ALPHABET, counts)
    pwm = fpm.normalize(pseudocounts=pseudocounts)
    
    # Position 0: A=7.5, C=2.5, G=1.5, T=0.5, total=12
    assertAlmostEqual(pwm["A"][0], 7.5/12.0)
    assertAlmostEqual(pwm["C"][0], 2.5/12.0)

# ============================================================================
# PositionWeightMatrix Tests  
# ============================================================================

@test
def test_position_weight_matrix_init():
    """Test PositionWeightMatrix initialization"""
    pwm = PositionWeightMatrix()
    assertEqual(pwm.alphabet, "")
    assertEqual(pwm.length, 0)

@test
def test_position_weight_matrix_init_with_data():
    """Test PositionWeightMatrix initialization with data"""
    counts = {
        "A": [8.0, 1.0, 1.0, 8.0],
        "C": [2.0, 8.0, 1.0, 1.0],
        "G": [1.0, 1.0, 8.0, 1.0],
        "T": [1.0, 1.0, 1.0, 1.0]
    }
    
    pwm = PositionWeightMatrix()
    pwm.init_with_data(TEST_ALPHABET, counts)
    assertEqual(pwm.alphabet, TEST_ALPHABET)
    assertEqual(pwm.length, 4)
    
    # Check normalization - probabilities should sum to 1
    for i in range(4):
        total = sum(pwm[letter][i] for letter in TEST_ALPHABET)
        assertAlmostEqual(total, 1.0)

@test
def test_position_weight_matrix_getitem():
    """Test PositionWeightMatrix indexing"""
    counts = {
        "A": [8.0, 1.0],
        "C": [2.0, 8.0],
        "G": [1.0, 1.0],
        "T": [1.0, 1.0]
    }
    
    pwm = PositionWeightMatrix()
    pwm.init_with_data(TEST_ALPHABET, counts)
    
    # Test letter indexing
    assertEqual(len(pwm["A"]), 2)
    
    # Test tuple indexing
    assertAlmostEqual(pwm["A", 0], 8.0/12.0)  # 8/(8+2+1+1)
    assertAlmostEqual(pwm["C", 1], 8.0/11.0)  # 8/(1+8+1+1)

@test
def test_position_weight_matrix_log_odds():
    """Test log odds calculation for PSSM"""
    counts = {
        "A": [8.0, 1.0, 1.0, 8.0],
        "C": [2.0, 8.0, 1.0, 1.0],
        "G": [1.0, 1.0, 8.0, 1.0],
        "T": [1.0, 1.0, 1.0, 1.0]
    }
    
    pwm = PositionWeightMatrix()
    pwm.init_with_data(TEST_ALPHABET, counts)
    pssm = pwm.log_odds()
    
    # Check that it returns a PositionSpecificScoringMatrix
    assertTrue(isinstance(pssm, PositionSpecificScoringMatrix))
    
    # With uniform background (0.25 each), log odds should be log2(prob/0.25)
    # Position 0: A prob = 8/12 = 2/3, log2((2/3)/0.25) = log2(8/3)
    expected_a0 = math.log2((8.0/12.0) / 0.25)
    assertAlmostEqual(pssm["A"][0], expected_a0, places=5)

@test
def test_position_weight_matrix_log_odds_custom_background():
    """Test log odds with custom background"""
    counts = {
        "A": [8.0, 1.0],
        "C": [2.0, 8.0],
        "G": [1.0, 1.0],
        "T": [1.0, 2.0]
    }

    background = {"A": 0.3, "C": 0.2, "G": 0.2, "T": 0.3}
    
    pwm = PositionWeightMatrix()
    pwm.init_with_data(TEST_ALPHABET, counts)
    pssm = pwm.log_odds(background)
    
    # Position 0: A prob = 8/12 = 2/3, log2((2/3)/0.3)
    expected_a0 = math.log2((8.0/12.0) / 0.3)
    assertAlmostEqual(pssm["A"][0], expected_a0, places=5)

# ============================================================================
# PositionSpecificScoringMatrix Tests
# ============================================================================

@test
def test_position_specific_scoring_matrix_init():
    """Test PSSM initialization"""
    pssm = PositionSpecificScoringMatrix()
    assertEqual(pssm.alphabet, "")
    assertEqual(pssm.length, 0)

@test
def test_position_specific_scoring_matrix_init_with_data():
    """Test PSSM initialization with data"""
    values = {
        "A": [2.0, -1.0, -2.0, 3.0],
        "C": [-1.0, 2.0, -1.0, -2.0],
        "G": [-2.0, -2.0, 3.0, -1.0],
        "T": [-3.0, -3.0, -3.0, 0.0]
    }
    
    pssm = PositionSpecificScoringMatrix()
    pssm.init_with_data(TEST_ALPHABET, values)
    assertEqual(pssm.alphabet, TEST_ALPHABET)
    assertEqual(pssm.length, 4)

@test
def test_position_specific_scoring_matrix_getitem():
    """Test PSSM indexing"""
    values = {
        "A": [2.0, -1.0],
        "C": [-1.0, 2.0],
        "G": [-2.0, -2.0],
        "T": [-3.0, -3.0]
    }
    
    pssm = PositionSpecificScoringMatrix()
    pssm.init_with_data(TEST_ALPHABET, values)
    
    # Test letter indexing
    assertEqual(len(pssm["A"]), 2)
    
    # Test tuple indexing
    assertAlmostEqual(pssm["A", 0], 2.0)
    assertAlmostEqual(pssm["C", 1], 2.0)

@test
def test_position_specific_scoring_matrix_max_min():
    """Test max and min score calculations"""
    values = {
        "A": [2.0, -1.0, -2.0, 3.0],
        "C": [-1.0, 2.0, -1.0, -2.0],
        "G": [-2.0, -2.0, 3.0, -1.0],
        "T": [-3.0, -3.0, -3.0, 0.0]
    }
    
    pssm = PositionSpecificScoringMatrix()
    pssm.init_with_data(TEST_ALPHABET, values)
    
    # Max score: take maximum at each position
    # Pos 0: max(2,-1,-2,-3) = 2
    # Pos 1: max(-1,2,-2,-3) = 2  
    # Pos 2: max(-2,-1,3,-3) = 3
    # Pos 3: max(3,-2,-1,0) = 3
    expected_max = 2.0 + 2.0 + 3.0 + 3.0
    assertAlmostEqual(pssm.max, expected_max)
    
    # Min score: take minimum at each position
    expected_min = -3.0 + (-3.0) + (-3.0) + (-2.0)
    assertAlmostEqual(pssm.min, expected_min)

@test
def test_position_specific_scoring_matrix_calculate_same_length():
    """Test PSSM calculate method with sequence same length as motif"""
    values = {
        "A": [2.0, -1.0, -2.0, 3.0],
        "C": [-1.0, 2.0, -1.0, -2.0],
        "G": [-2.0, -2.0, 3.0, -1.0],
        "T": [-3.0, -3.0, -3.0, 0.0]
    }
    
    pssm = PositionSpecificScoringMatrix()
    pssm.init_with_data(TEST_ALPHABET, values)
    
    # Test with sequence same length as motif
    scores = pssm.calculate("ACGT")
    
    # Should return list with single score: A[0] + C[1] + G[2] + T[3] = 2 + 2 + 3 + 0 = 7
    expected_score = 2.0 + 2.0 + 3.0 + 0.0
    assertEqual(len(scores), 1)
    assertAlmostEqual(scores[0], expected_score)

@test
def test_position_specific_scoring_matrix_calculate_longer_sequence():
    """Test PSSM calculate method with longer sequence"""
    values = {
        "A": [1.0, 0.0],
        "C": [0.0, 1.0],
        "G": [-1.0, -1.0],
        "T": [-2.0, -2.0]
    }
    
    pssm = PositionSpecificScoringMatrix()
    pssm.init_with_data(TEST_ALPHABET, values)
    
    # Test with longer sequence
    scores = pssm.calculate("ACGT")
    
    # Should return list of scores for each possible position
    assertTrue(isinstance(scores, list))
    assertEqual(len(scores), 3)  # 4 - 2 + 1 = 3 positions
    
    # Check individual scores
    # Position 0: A[0] + C[1] = 1 + 1 = 2
    # Position 1: C[0] + G[1] = 0 + (-1) = -1  
    # Position 2: G[0] + T[1] = (-1) + (-2) = -3
    assertAlmostEqual(scores[0], 2.0)
    assertAlmostEqual(scores[1], -1.0)
    assertAlmostEqual(scores[2], -3.0)

@test
def test_position_specific_scoring_matrix_calculate_short_sequence():
    """Test PSSM calculate with sequence shorter than motif"""
    values = {
        "A": [1.0, 0.0, 2.0],
        "C": [0.0, 1.0, 0.0],
        "G": [-1.0, -1.0, -1.0],
        "T": [-2.0, -2.0, -2.0]
    }
    
    pssm = PositionSpecificScoringMatrix()
    pssm.init_with_data(TEST_ALPHABET, values)
    
    # Test with sequence shorter than motif
    scores = pssm.calculate("AC")  # Length 2, motif length 3
    
    # Should return empty list
    assertEqual(len(scores), 0)

@test
def test_position_specific_scoring_matrix_calculate_with_seq_object():
    """Test PSSM calculate with Seq object"""
    values = {
        "A": [1.0, 0.0],
        "C": [0.0, 1.0],
        "G": [-1.0, -1.0],
        "T": [-2.0, -2.0]
    }
    
    pssm = PositionSpecificScoringMatrix()
    pssm.init_with_data(TEST_ALPHABET, values)
    
    test_seq = Seq("ac")  # Test lowercase
    scores = pssm.calculate(test_seq)
    
    # A[0] + C[1] = 1 + 1 = 2
    expected_score = 2.0
    assertEqual(len(scores), 1)
    assertAlmostEqual(scores[0], expected_score)

@test
def test_position_specific_scoring_matrix_calculate_wrong_alphabet():
    """Test PSSM calculate with wrong alphabet"""
    values = {
        "X": [1.0, 0.0],
        "Y": [0.0, 1.0],
        "Z": [-1.0, -1.0]
    }
    
    pssm = PositionSpecificScoringMatrix()
    pssm.init_with_data("XYZ", values)
    
    try:
        pssm.calculate("AC")
        assert False, "Expected ValueError to be raised"
    except ValueError:
        pass
    
@test  
def test_position_specific_scoring_matrix_gc_content():
    """Test that PSSM gc_content raises exception"""
    values = {
        "A": [1.0, 0.0],
        "C": [0.0, 1.0],
        "G": [-1.0, -1.0],
        "T": [-2.0, -2.0]
    }
    
    pssm = PositionSpecificScoringMatrix()
    pssm.init_with_data(TEST_ALPHABET, values)
    
    try:
        gc_content = pssm.gc_content
        assert False, "Expected Exception to be raised"
    except Exception:
        pass 

@test
def test_position_specific_scoring_matrix_mean():
    """Test PSSM mean calculation"""
    values = {
        "A": [1.0, 0.0],
        "C": [0.0, 1.0],
        "G": [-1.0, -1.0],
        "T": [-2.0, -2.0]
    }
    
    pssm = PositionSpecificScoringMatrix()
    pssm.init_with_data(TEST_ALPHABET, values)
    
    # Test with uniform background (default)
    mean_score = pssm.mean()
    assertTrue(isinstance(mean_score, float))
    
    # Test with custom background
    background = {"A": 0.3, "C": 0.2, "G": 0.2, "T": 0.3}
    mean_custom = pssm.mean(background)
    assertTrue(isinstance(mean_custom, float))

@test
def test_position_specific_scoring_matrix_std():
    """Test PSSM standard deviation calculation"""
    values = {
        "A": [1.0, 0.0],
        "C": [0.0, 1.0],
        "G": [-1.0, -1.0],
        "T": [-2.0, -2.0]
    }
    
    pssm = PositionSpecificScoringMatrix()
    pssm.init_with_data(TEST_ALPHABET, values)
    
    # Test with uniform background (default)
    std_score = pssm.std()
    assertTrue(isinstance(std_score, float))
    assertTrue(std_score >= 0.0)  # Standard deviation should be non-negative
    
    # Test with custom background
    background = {"A": 0.3, "C": 0.2, "G": 0.2, "T": 0.3}
    std_custom = pssm.std(background)
    assertTrue(isinstance(std_custom, float))
    assertTrue(std_custom >= 0.0)

@test
def test_position_specific_scoring_matrix_dist_pearson():
    """Test PSSM Pearson distance calculation"""
    values1 = {
        "A": [2.0, -1.0, 1.0],
        "C": [-1.0, 2.0, 0.0],
        "G": [-2.0, -2.0, 2.0],
        "T": [-3.0, -3.0, -1.0]
    }
    
    values2 = {
        "A": [1.0, 0.0, 2.0],
        "C": [0.0, 1.0, -1.0],
        "G": [-1.0, -1.0, 1.0],
        "T": [-2.0, -2.0, 0.0]
    }
    
    pssm1 = PositionSpecificScoringMatrix()
    pssm1.init_with_data(TEST_ALPHABET, values1)
    
    pssm2 = PositionSpecificScoringMatrix()
    pssm2.init_with_data(TEST_ALPHABET, values2)
    
    # Test Pearson correlation distance
    dist_result = pssm1.dist_pearson(pssm2)
    
    # Should return a tuple (distance, offset)
    assertTrue(isinstance(dist_result, tuple))
    assertEqual(len(dist_result), 2)
    
    distance, offset = dist_result
    assertTrue(isinstance(distance, float))
    assertTrue(isinstance(offset, int))

@test
def test_position_specific_scoring_matrix_dist_pearson_at():
    """Test PSSM Pearson distance at specific offset"""
    values1 = {
        "A": [2.0, -1.0],
        "C": [-1.0, 2.0],
        "G": [-2.0, -2.0],
        "T": [-3.0, -3.0]
    }
    
    values2 = {
        "A": [1.0, 0.0],
        "C": [0.0, 1.0],
        "G": [-1.0, -1.0],
        "T": [-2.0, -2.0]
    }
    
    pssm1 = PositionSpecificScoringMatrix()
    pssm1.init_with_data(TEST_ALPHABET, values1)
    
    pssm2 = PositionSpecificScoringMatrix()
    pssm2.init_with_data(TEST_ALPHABET, values2)
    
    # Test Pearson correlation at specific offset
    pearson_at_offset = pssm1.dist_pearson_at(pssm2, 0)
    assertTrue(isinstance(pearson_at_offset, float))

@test
def test_position_specific_scoring_matrix_different_alphabets():
    """Test PSSM distance with different alphabets raises error"""
    values1 = {
        "A": [2.0, -1.0],
        "C": [-1.0, 2.0],
        "G": [-2.0, -2.0],
        "T": [-3.0, -3.0]
    }
    
    values2 = {
        "A": [1.0, 0.0],
        "C": [0.0, 1.0],
        "G": [-1.0, -1.0],
        "U": [-2.0, -2.0]  # Different alphabet (RNA)
    }
    
    pssm1 = PositionSpecificScoringMatrix()
    pssm1.init_with_data("ACGT", values1)
    
    pssm2 = PositionSpecificScoringMatrix()
    pssm2.init_with_data("ACGU", values2)
    
    try:
        pssm1.dist_pearson(pssm2)
        assert False, "Expected ValueError to be raised"
    except ValueError:
        pass  # This is what we expected

# ============================================================================
# Edge Cases and Error Handling Tests
# ============================================================================

@test
def test_edge_cases_empty_alphabet():
    """Test edge case with empty alphabet"""
    # Empty alphabet should create an empty matrix
    gpm = GenericPositionMatrix("", {})
    assertEqual(gpm.length, 0)
    assertEqual(gpm.alphabet, "")

@test
def test_edge_cases_zero_counts():
    """Test edge case with all zero counts"""
    zero_counts = {
        "A": [0.0, 0.0, 0.0, 0.0],
        "C": [0.0, 0.0, 0.0, 0.0],
        "G": [0.0, 0.0, 0.0, 0.0],
        "T": [0.0, 0.0, 0.0, 0.0]
    }
    
    fpm = FrequencyPositionMatrix(TEST_ALPHABET, zero_counts)
    
    pwm = fpm.normalize()
    # Check that we get some valid result (might be NaN or uniform)
    assertTrue(pwm.length == 4)

@test
def test_edge_cases_single_position():
    """Test edge case with single position matrix"""
    single_pos_values = {
        "A": [5.0],
        "C": [3.0],
        "G": [1.0],
        "T": [1.0]
    }
    
    gpm = GenericPositionMatrix(TEST_ALPHABET, single_pos_values)
    assertEqual(gpm.length, 1)
    assertEqual(str(gpm.consensus), "A")
    assertEqual(str(gpm.anticonsensus), "G")  # or T, whichever is found first

@test
def test_edge_cases_very_large_values():
    """Test edge case with very large values"""
    large_values = {
        "A": [1e10, 1e5],
        "C": [1e5, 1e10], 
        "G": [1.0, 1.0],
        "T": [1.0, 1.0]
    }
    
    gpm = GenericPositionMatrix(TEST_ALPHABET, large_values)
    assertTrue(gpm.length == 2)
    
    # Should still work correctly
    consensus = gpm.consensus
    assertEqual(str(consensus), "AC")

@test
def test_edge_cases_negative_values():
    """Test edge case with negative values (valid for PSSM)"""
    negative_values = {
        "A": [-1.0, -2.0],
        "C": [-3.0, -1.0],
        "G": [-2.0, -3.0],
        "T": [-4.0, -4.0]
    }
    
    pssm = PositionSpecificScoringMatrix()
    pssm.init_with_data(TEST_ALPHABET, negative_values)
    
    # Max should still work (least negative)
    max_score = pssm.max
    expected_max = -1.0 + (-1.0)  # A[0] + C[1]
    assertAlmostEqual(max_score, expected_max)
    
    # Min should be most negative
    min_score = pssm.min
    expected_min = -4.0 + (-4.0)  # T[0] + T[1]
    assertAlmostEqual(min_score, expected_min)

@test
def test_edge_cases_infinite_values():
    """Test edge case with infinite values"""
    inf_values = {
        "A": [math.inf, 1.0],
        "C": [1.0, -math.inf],
        "G": [1.0, 1.0],
        "T": [1.0, 1.0]
    }
    
    pssm = PositionSpecificScoringMatrix()
    pssm.init_with_data(TEST_ALPHABET, inf_values)
    
    # Max should include the infinite value
    max_score = pssm.max
    assertTrue(math.isinf(max_score))
    
    # Min should include negative infinite value  
    min_score = pssm.min
    assertTrue(math.isinf(min_score) and min_score < 0)

@test
def test_edge_cases_nan_values():
    """Test edge case with NaN values"""
    nan_values = {
        "A": [math.nan, 1.0],
        "C": [1.0, math.nan],
        "G": [1.0, 1.0],
        "T": [1.0, 1.0]
    }
    
    pssm = PositionSpecificScoringMatrix()
    pssm.init_with_data(TEST_ALPHABET, nan_values)
    
    # Should handle NaN gracefully in calculations
    try:
        mean_val = pssm.mean()
        std_val = pssm.std()
        # These might be NaN or computed ignoring NaN values
        assertTrue(isinstance(mean_val, float))
        assertTrue(isinstance(std_val, float))
    except:
        # Or they might raise exceptions, which is also acceptable
        pass

# ============================================================================
# Integration Tests
# ============================================================================

@test
def test_integration_frequency_to_pwm_to_pssm():
    """Test full pipeline: FPM -> PWM -> PSSM"""
    # Start with count data
    counts = {
        "A": [20.0, 5.0, 5.0, 30.0],
        "C": [5.0, 30.0, 5.0, 5.0],
        "G": [5.0, 5.0, 30.0, 5.0],
        "T": [5.0, 5.0, 5.0, 5.0]
    }
    
    # Step 1: Create FPM
    fpm = FrequencyPositionMatrix(TEST_ALPHABET, counts)
    assertEqual(fpm.length, 4)
    
    # Step 2: Normalize to PWM
    pwm = fpm.normalize(pseudocounts=1.0)
    assertTrue(isinstance(pwm, PositionWeightMatrix))
    
    # Step 3: Convert to PSSM
    pssm = pwm.log_odds()
    assertTrue(isinstance(pssm, PositionSpecificScoringMatrix))
    
    # Step 4: Test scoring
    test_sequence = "ACGT"
    scores = pssm.calculate(test_sequence)
    assertTrue(isinstance(scores, list))
    assertTrue(len(scores) == 1)
    
    # The score should be positive since ACGT matches the consensus
    assertTrue(scores[0] > 0)

@test
def test_integration_reverse_complement_consistency():
    """Test that reverse complement operations are consistent"""
    counts = {
        "A": [10.0, 1.0, 2.0, 0.0],
        "C": [1.0, 2.0, 1.0, 1.0],
        "G": [1.0, 10.0, 7.0, 2.0],
        "T": [0.0, 1.0, 0.0, 10.0]
    }
    
    # Test with GenericPositionMatrix
    gpm = GenericPositionMatrix(TEST_ALPHABET, counts)
    rc_gpm = gpm.reverse_complement()
    
    # Double reverse complement should give original
    rc_rc_gpm = rc_gpm.reverse_complement()
    
    for letter in TEST_ALPHABET:
        for i in range(gpm.length):
            assertAlmostEqual(gpm[letter][i], rc_rc_gpm[letter][i])

@test
def test_integration_consensus_scoring():
    """Test that consensus sequence gets high score"""
    counts = {
        "A": [30.0, 1.0, 1.0, 1.0],
        "C": [1.0, 30.0, 1.0, 1.0],
        "G": [1.0, 1.0, 30.0, 1.0],
        "T": [1.0, 1.0, 1.0, 30.0]
    }
    
    # Create matrices
    fpm = FrequencyPositionMatrix(TEST_ALPHABET, counts)
    pwm = fpm.normalize(pseudocounts=1.0)
    pssm = pwm.log_odds()
    
    # Get consensus from original matrix
    gpm = GenericPositionMatrix(TEST_ALPHABET, counts)
    consensus = str(gpm.consensus)
    
    # Score the consensus sequence
    scores = pssm.calculate(consensus)
    
    # Should return list with one score
    assertEqual(len(scores), 1)
    consensus_score = scores[0]
    
    # Score should be close to maximum possible
    max_score = pssm.max
    assertAlmostEqual(consensus_score, max_score, places=3)

# ============================================================================
# Test Runner Functions
# ============================================================================

def run_basic_tests():
    """Run basic functionality tests"""
    print("=== Running Basic Tests ===")
    test_generic_position_matrix_init()
    test_generic_position_matrix_inconsistent_lengths()
    test_generic_position_matrix_str()
    test_generic_position_matrix_getitem()
    test_generic_position_matrix_setitem()
    test_generic_position_matrix_keys()
    print("✅ Basic GenericPositionMatrix tests passed")

def run_property_tests():
    """Run property calculation tests"""
    print("=== Running Property Tests ===")
    test_generic_position_matrix_consensus()
    test_generic_position_matrix_anticonsensus()
    test_generic_position_matrix_degenerate_consensus()
    test_generic_position_matrix_calculate_consensus()
    test_generic_position_matrix_gc_content()
    test_reverse_complement()
    print("✅ Property calculation tests passed")

def run_frequency_matrix_tests():
    """Run FrequencyPositionMatrix tests"""
    print("=== Running FrequencyPositionMatrix Tests ===")
    test_frequency_position_matrix()
    test_frequency_position_matrix_normalize()
    test_frequency_position_matrix_normalize_with_pseudocounts()
    test_frequency_position_matrix_normalize_with_dict_pseudocounts()
    print("✅ FrequencyPositionMatrix tests passed")

def run_weight_matrix_tests():
    """Run PositionWeightMatrix tests"""
    print("=== Running PositionWeightMatrix Tests ===")
    test_position_weight_matrix_init()
    test_position_weight_matrix_init_with_data()
    test_position_weight_matrix_getitem()
    test_position_weight_matrix_log_odds()
    test_position_weight_matrix_log_odds_custom_background()
    print("✅ PositionWeightMatrix tests passed")

def run_scoring_matrix_tests():
    """Run PositionSpecificScoringMatrix tests"""
    print("=== Running PositionSpecificScoringMatrix Tests ===")
    test_position_specific_scoring_matrix_init()
    test_position_specific_scoring_matrix_init_with_data()
    test_position_specific_scoring_matrix_getitem()
    test_position_specific_scoring_matrix_max_min()
    test_position_specific_scoring_matrix_calculate_same_length()
    test_position_specific_scoring_matrix_calculate_longer_sequence()
    test_position_specific_scoring_matrix_calculate_short_sequence()
    test_position_specific_scoring_matrix_calculate_with_seq_object()
    test_position_specific_scoring_matrix_calculate_wrong_alphabet()
    test_position_specific_scoring_matrix_gc_content()
    test_position_specific_scoring_matrix_mean()
    test_position_specific_scoring_matrix_std()
    test_position_specific_scoring_matrix_dist_pearson()
    test_position_specific_scoring_matrix_dist_pearson_at()
    test_position_specific_scoring_matrix_different_alphabets()
    print("✅ PositionSpecificScoringMatrix tests passed")

def run_edge_case_tests():
    """Run edge case and error handling tests"""
    print("=== Running Edge Case Tests ===")
    test_edge_cases_empty_alphabet()
    test_edge_cases_zero_counts()
    test_edge_cases_single_position()
    test_edge_cases_very_large_values()
    test_edge_cases_negative_values()
    test_edge_cases_infinite_values()
    test_edge_cases_nan_values()
    print("✅ Edge case tests passed")

def run_integration_tests():
    """Run integration tests"""
    print("=== Running Integration Tests ===")
    test_integration_frequency_to_pwm_to_pssm()
    test_integration_reverse_complement_consistency()
    test_integration_consensus_scoring()
    print("✅ Integration tests passed")

def run_all_tests():
    """Run all test functions"""
    print("🧬 Starting Comprehensive Bio.motifs.matrix Tests 🧬")
    print("=" * 60)
    
    try:
        run_basic_tests()
        run_property_tests()
        run_frequency_matrix_tests()
        run_weight_matrix_tests()
        run_scoring_matrix_tests()
        run_edge_case_tests()
        run_integration_tests()
        
        print("=" * 60)
        print("🎉 ALL TESTS PASSED! 🎉")
        print("Coverage: Complete Bio.motifs.matrix module functionality")
        print("Classes tested:")
        print("  ✅ GenericPositionMatrix (complete)")
        print("  ✅ FrequencyPositionMatrix (complete)")
        print("  ✅ PositionWeightMatrix (complete)")
        print("  ✅ PositionSpecificScoringMatrix (complete)")
        print("  ✅ Seq helper class (complete)")
        print("=" * 60)
        
    except Exception as e:
        print("❌ TEST FAILED:", str(e))
        print("=" * 60)

# Execute all tests when this file is run
if __name__ == "__main__":
    run_all_tests()