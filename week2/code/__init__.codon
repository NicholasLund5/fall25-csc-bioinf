import math
from typing import Optional, List, Dict, Tuple

# Import matrix classes from our Codon implementation
from matrix import FrequencyPositionMatrix, PositionWeightMatrix, PositionSpecificScoringMatrix

# Import dependencies from Python - ALL must use 'from python import' syntax
from python import Bio.motifs.jaspar as jaspar
from python import Bio.motifs.transfac as transfac
from python import Bio.motifs.clusterbuster as clusterbuster
import minimal

class SimpleAlignment:
    """Simple alignment class for Codon compatibility"""
    sequences: List[str]
    length: int
    
    def __init__(self, sequences: List[str]):
        self.sequences = sequences
        if sequences:
            self.length = len(sequences[0])
            # Verify all sequences have same length
            for seq in sequences:
                if len(seq) != self.length:
                    raise ValueError("All sequences must have the same length")
        else:
            self.length = 0
    
    def __len__(self) -> int:
        return len(self.sequences)
    
    def __str__(self) -> str:
        return "\n".join(self.sequences)
    
    def __getitem__(self, index: int) -> str:
        return self.sequences[index]
    
    def frequencies(self, alphabet: str) -> Dict[str, List[float]]:
        """Calculate position frequencies for each letter"""
        freqs = Dict[str, List[float]]()
        
        for letter in alphabet:
            freqs[letter] = []
            for pos in range(self.length):
                count = 0.0
                for seq in self.sequences:
                    if pos < len(seq) and seq[pos] == letter:
                        count += 1.0
                freqs[letter].append(count)
        
        return freqs
    
    def get_slice(self, start: int, stop: int) -> SimpleAlignment:
        """Get a slice of the alignment"""
        new_sequences = List[str]()
        for seq in self.sequences:
            new_sequences.append(seq[start:stop])
        return SimpleAlignment(new_sequences)
    
    def reverse_complement(self) -> SimpleAlignment:
        """Return reverse complement of DNA/RNA alignment"""
        complement_map = {
            'A': 'T', 'T': 'A', 'G': 'C', 'C': 'G',
            'a': 't', 't': 'a', 'g': 'c', 'c': 'g',
            'U': 'A', 'u': 'a'
        }
        
        new_sequences = List[str]()
        for seq in self.sequences:
            rev_seq = seq[::-1]
            comp_seq = ""
            for base in rev_seq:
                if base in complement_map:
                    comp_seq += complement_map[base]
                else:
                    comp_seq += base
            new_sequences.append(comp_seq)
        
        return SimpleAlignment(new_sequences)

class Motif:
    """A class representing sequence motifs."""
    
    name: str
    alphabet: str
    _alignment: Optional[SimpleAlignment]
    _counts: Optional[object]
    length: int
    _mask: Tuple[int]
    _pseudocounts: Dict[str, float]
    _background: Dict[str, float]
    
    def __init__(self, 
                 alphabet: str = "ACGT",
                 alignment: Optional[SimpleAlignment] = None,
                 counts: Optional[Dict[str, List[float]]] = None):
        """Initialize the Motif class."""
        self.name = ""
        self.alphabet = alphabet
        self._alignment = None
        self._counts = None
        self.length = 0
        
        # Initialize empty mask - will be set properly below
        self._mask = ()
        
        # Initialize pseudocounts and background
        self._pseudocounts = Dict[str, float]()
        self._background = Dict[str, float]()
        
        for letter in alphabet:
            self._pseudocounts[letter] = 0.0
            self._background[letter] = 1.0
        
        # Process counts or alignment
        if counts is not None and alignment is not None:
            raise ValueError("Specify either counts or an alignment, don't specify both")
        elif counts is not None:
            self._alignment = None
            self._counts = FrequencyPositionMatrix(alphabet, counts)
            self.length = self._counts.length
        elif alignment is not None:
            self.length = alignment.length
            frequencies = alignment.frequencies(alphabet)
            
            # Ensure all letters have frequencies
            for letter in alphabet:
                if letter not in frequencies:
                    zero_freqs = List[float]()
                    for i in range(self.length):
                        zero_freqs.append(0.0)
                    frequencies[letter] = zero_freqs
            
            self._counts = FrequencyPositionMatrix(alphabet, frequencies)
            self._alignment = alignment
        else:
            self._counts = None
            self._alignment = None
            self.length = 0
        
        # Initialize mask based on length
        if self.length > 0:
            mask_list = List[int]()
            for i in range(self.length):
                mask_list.append(1)
            self._mask = tuple(mask_list)
        else:
            self._mask = ()
    
    @property
    def mask(self) -> Tuple[int]:
        """Get the mask."""
        return self._mask
    
    def set_mask(self, mask):
        """Set the mask for the motif."""
        if self.length == 0:
            self._mask = ()
        elif mask is None:
            mask_list = List[int]()
            for i in range(self.length):
                mask_list.append(1)
            self._mask = tuple(mask_list)
        elif isinstance(mask, str):
            if len(mask) != self.length:
                raise ValueError("Mask length does not match motif length")
            mask_list = List[int]()
            for char in mask:
                if char == "*":
                    mask_list.append(1)
                elif char == " ":
                    mask_list.append(0)
                else:
                    raise ValueError("Mask should contain only '*' or ' '")
            self._mask = tuple(mask_list)
        else:
            # Assume it's a list or tuple of int-like values
            if len(mask) != self.length:
                raise ValueError("Mask length does not match motif length")
            mask_list = List[int]()
            for val in mask:
                mask_list.append(1 if val else 0)
            self._mask = tuple(mask_list)
    
    @property 
    def pseudocounts(self) -> Dict[str, float]:
        """Get pseudocounts."""
        return self._pseudocounts
    
    def set_pseudocounts(self, value):
        """Set pseudocounts for the motif."""
        self._pseudocounts = Dict[str, float]()
        
        if isinstance(value, dict) or isinstance(value, Dict[str, float]):
            for letter in self.alphabet:
                if letter in value:
                    self._pseudocounts[letter] = float(value[letter])
                else:
                    self._pseudocounts[letter] = 0.0
        elif value is None:
            for letter in self.alphabet:
                self._pseudocounts[letter] = 0.0
        else:
            # Single value for all letters
            val = float(value)
            for letter in self.alphabet:
                self._pseudocounts[letter] = val
    
    @property
    def background(self) -> Dict[str, float]:
        """Get background frequencies."""
        return self._background
    
    def set_background(self, value):
        """Set background frequencies for the motif."""
        if isinstance(value, dict) or isinstance(value, Dict[str, float]):
            self._background = Dict[str, float]()
            for letter in self.alphabet:
                if letter in value:
                    self._background[letter] = float(value[letter])
                else:
                    self._background[letter] = 1.0
        elif value is None:
            self._background = Dict[str, float]()
            for letter in self.alphabet:
                self._background[letter] = 1.0
        else:
            # Interpret as GC content for DNA/RNA
            if not self._has_dna_alphabet() and not self._has_rna_alphabet():
                raise ValueError("Single value background only works for DNA/RNA motifs")
            
            gc_content = float(value)
            self._background = Dict[str, float]()
            
            T_or_U = "T" if self._has_dna_alphabet() else "U"
            self._background["A"] = (1.0 - gc_content) / 2.0
            self._background["C"] = gc_content / 2.0
            self._background["G"] = gc_content / 2.0
            self._background[T_or_U] = (1.0 - gc_content) / 2.0
        
        # Normalize
        total = 0.0
        for letter in self.alphabet:
            total += self._background[letter]
        
        if total > 0:
            for letter in self.alphabet:
                self._background[letter] /= total
    
    def __len__(self) -> int:
        """Return the length of the motif."""
        return self.length
    
    def __str__(self) -> str:
        """Return string representation of the motif."""
        text = ""
        if self._alignment is not None:
            text += str(self._alignment)
        return text
    
    def __getitem__(self, key: Tuple[int, int]) -> Motif:
        """Return a new Motif object for the positions from start to stop."""
        start, stop = key
        alphabet = self.alphabet
        
        if self._alignment is None:
            alignment = None
            if self._counts is None:
                counts = None
            else:
                counts = Dict[str, List[float]]()
                for letter in alphabet:
                    counts[letter] = self._counts.data[letter][start:stop]
        else:
            alignment = self._alignment.get_slice(start, stop)
            counts = None
        
        motif = Motif(alphabet=alphabet, alignment=alignment, counts=counts)
        
        # Copy mask for the slice
        new_mask = List[int]()
        for i in range(start, min(stop, len(self._mask))):
            new_mask.append(self._mask[i])
        motif._mask = tuple(new_mask)
        
        # Copy pseudocounts and background
        motif._pseudocounts = Dict[str, float]()
        motif._background = Dict[str, float]()
        for letter in alphabet:
            motif._pseudocounts[letter] = self._pseudocounts[letter]
            motif._background[letter] = self._background[letter]
        
        return motif
    
    def _has_dna_alphabet(self) -> bool:
        """Check if alphabet is DNA."""
        dna_letters = ["A", "C", "G", "T"]
        if len(self.alphabet) != 4:
            return False
        for letter in self.alphabet:
            if letter not in dna_letters:
                return False
        return True
    
    def _has_rna_alphabet(self) -> bool:
        """Check if alphabet is RNA."""
        rna_letters = ["A", "C", "G", "U"]
        if len(self.alphabet) != 4:
            return False
        for letter in self.alphabet:
            if letter not in rna_letters:
                return False
        return True
    
    @property
    def pwm(self) -> PositionWeightMatrix:
        """Calculate and return the position weight matrix."""
        if self._counts is None:
            raise ValueError("Cannot calculate PWM without counts")
        return self._counts.normalize(self._pseudocounts)
    
    @property
    def pssm(self) -> PositionSpecificScoringMatrix:
        """Calculate and return the position specific scoring matrix."""
        pwm = self.pwm
        return pwm.log_odds(self._background)
    
    @property
    def consensus(self) -> str:
        """Return the consensus sequence."""
        if self._counts is None:
            return ""
        consensus_seq = self._counts.consensus
        return str(consensus_seq)
    
    @property
    def anticonsensus(self) -> str:
        """Return the anticonsensus sequence."""
        if self._counts is None:
            return ""
        anticonsensus_seq = self._counts.anticonsensus
        return str(anticonsensus_seq)
    
    @property
    def degenerate_consensus(self) -> str:
        """Return the degenerate consensus sequence."""
        if self._counts is None:
            return ""
        degenerate_seq = self._counts.degenerate_consensus
        return str(degenerate_seq)
    
    def reverse_complement(self) -> Motif:
        """Return the reverse complement of the motif."""
        if not self._has_dna_alphabet() and not self._has_rna_alphabet():
            raise ValueError("Reverse complement only works for DNA/RNA motifs")
        
        T_or_U = "T" if self._has_dna_alphabet() else "U"
        
        if self._alignment is not None:
            rc_alignment = self._alignment.reverse_complement()
            if T_or_U == "U":
                # Replace T with U in sequences
                new_sequences = List[str]()
                for seq in rc_alignment.sequences:
                    new_sequences.append(seq.replace("T", "U"))
                rc_alignment = SimpleAlignment(new_sequences)
            res = Motif(alphabet=self.alphabet, alignment=rc_alignment)
        else:
            # Reverse complement counts
            if self._counts is None:
                res = Motif(alphabet=self.alphabet)
            else:
                counts = Dict[str, List[float]]()
                counts["A"] = self._counts.data[T_or_U][::-1]
                counts["C"] = self._counts.data["G"][::-1]
                counts["G"] = self._counts.data["C"][::-1]
                counts[T_or_U] = self._counts.data["A"][::-1]
                res = Motif(alphabet=self.alphabet, counts=counts)
        
        # Reverse mask
        reversed_mask = List[int]()
        for i in range(len(self._mask) - 1, -1, -1):
            reversed_mask.append(self._mask[i])
        res._mask = tuple(reversed_mask)
        
        # Swap background and pseudocounts
        res._background = Dict[str, float]()
        res._pseudocounts = Dict[str, float]()
        
        res._background["A"] = self._background[T_or_U]
        res._background["C"] = self._background["G"]
        res._background["G"] = self._background["C"]
        res._background[T_or_U] = self._background["A"]
        
        res._pseudocounts["A"] = self._pseudocounts[T_or_U]
        res._pseudocounts["C"] = self._pseudocounts["G"]
        res._pseudocounts["G"] = self._pseudocounts["C"]
        res._pseudocounts[T_or_U] = self._pseudocounts["A"]
        
        return res
    
    @property
    def relative_entropy(self) -> List[float]:
        """Calculate relative entropy for each position."""
        if self._counts is None:
            return []
        
        values = List[float]()
        for i in range(self.length):
            entropy = 0.0
            total = 0.0
            
            # Calculate total with pseudocounts
            for letter in self.alphabet:
                total += self._counts.data[letter][i] + self._pseudocounts[letter]
            
            if total > 0:
                for letter in self.alphabet:
                    freq = self._counts.data[letter][i] + self._pseudocounts[letter]
                    if freq > 0:
                        prob = freq / total
                        bg = self._background[letter]
                        if bg > 0:
                            entropy += prob * math.log2(prob / bg)
            
            values.append(entropy)
        
        return values
    
    def format(self, format_spec: str) -> str:
        """Format the motif in a specific format."""
        # Convert to Python motif and use BioPython formatters
        py_motif = _convert_codon_motif(self)
        return py_motif.format(format_spec)

# Now we can define functions that use Motif class
def create(instances: List[str], alphabet: str = "ACGT") -> Motif:
    """Create a Motif object from sequences."""
    alignment = SimpleAlignment(instances)
    return Motif(alphabet=alphabet, alignment=alignment)

def read(handle, fmt: str, strict: bool = True) -> Motif:
    """Read a motif from a handle using the specified file-format.
    
    This function reads exactly one motif from the file.
    For files with multiple motifs, use parse() instead.
    """
    fmt_lower = fmt.lower()
    
    # Use Python imports for format-specific parsing
    if fmt_lower == "minimal":
        motifs = minimal.read(handle)
    elif fmt_lower in ("pfm", "sites", "jaspar"):
        motifs = jaspar.read(handle, fmt_lower)
    elif fmt_lower == "transfac":
        motifs = transfac.read(handle, strict)
    elif fmt_lower == "clusterbuster":
        motifs = clusterbuster.read(handle)
    else:
        raise ValueError("Unknown format " + fmt)
    
    if len(motifs) == 0:
        raise ValueError("No motifs found in handle")
    if len(motifs) > 1:
        raise ValueError("More than one motif found in handle")
    
    # Convert Python motif to Codon Motif
    py_motif = motifs[0]
    return _convert_python_motif(py_motif)

def parse(handle, fmt: str, strict: bool = True) -> List[Motif]:
    """Parse an output file from a motif finding program.
    
    Returns a list of Motif objects.
    """
    fmt_lower = fmt.lower()
    
    # Use Python imports for format-specific parsing
    if fmt_lower == "minimal":
        py_motifs = minimal.read(handle)
    elif fmt_lower in ("pfm", "sites", "jaspar"):
        py_motifs = jaspar.read(handle, fmt_lower)
    elif fmt_lower == "transfac":
        py_motifs = transfac.read(handle, strict)
    elif fmt_lower == "clusterbuster":
        py_motifs = clusterbuster.read(handle)
    else:
        raise ValueError("Unknown format " + fmt)
    
    # Convert Python motifs to Codon Motifs
    result = List[Motif]()
    for py_motif in py_motifs:
        result.append(_convert_python_motif(py_motif))
    
    return result

def _convert_python_motif(py_motif) -> Motif:
    """Convert a Python BioPython motif to Codon Motif"""
    # Extract counts from Python motif
    alphabet = str(py_motif.alphabet)
    
    if hasattr(py_motif, 'counts') and py_motif.counts is not None:
        counts = Dict[str, List[float]]()
        for letter in alphabet:
            counts[letter] = list(py_motif.counts[letter])
        motif = Motif(alphabet=alphabet, counts=counts)
    elif hasattr(py_motif, 'alignment') and py_motif.alignment is not None:
        sequences = List[str]()
        for seq in py_motif.alignment:
            sequences.append(str(seq))
        alignment = SimpleAlignment(sequences)
        motif = Motif(alphabet=alphabet, alignment=alignment)
    else:
        motif = Motif(alphabet=alphabet)
    
    # Copy other attributes
    if hasattr(py_motif, 'name'):
        motif.name = str(py_motif.name)
    
    return motif

def write(motifs: List[Motif], fmt: str) -> str:
    """Return a string representation of motifs in the given format."""
    fmt_lower = fmt.lower()
    
    # Convert Codon motifs to Python format for writing
    py_motifs = []
    for motif in motifs:
        py_motif = _convert_codon_motif(motif)
        py_motifs.append(py_motif)
    
    if fmt_lower in ("pfm", "jaspar"):
        return jaspar.write(py_motifs, fmt_lower)
    elif fmt_lower == "transfac":
        return transfac.write(py_motifs)
    elif fmt_lower == "clusterbuster":
        return clusterbuster.write(py_motifs)
    else:
        raise ValueError("Unknown format type " + fmt)

def _convert_codon_motif(motif: Motif):
    """Convert a Codon Motif to Python BioPython motif"""
    from python import Bio.motifs as biomot
    
    # Create Python motif with counts
    if motif._counts is not None:
        py_counts = {}
        for letter in motif.alphabet:
            py_counts[letter] = motif._counts.data[letter]
        py_motif = biomot.Motif(alphabet=motif.alphabet, counts=py_counts)
    elif motif._alignment is not None:
        py_motif = biomot.create(motif._alignment.sequences, motif.alphabet)
    else:
        py_motif = biomot.Motif(alphabet=motif.alphabet)
    
    py_motif.name = motif.name
    return py_motif