# This source code is part of the Biotite package and is distributed
# under the 3-Clause BSD License. Please see 'LICENSE.rst' for further
# information.

from python import numpy as np
from numpy import ndarray, array, zeros, ones, full, float32, float64, int32, uint8, uint32, asarray
from typing import List, Optional

from tree import Tree, TreeNode
from upgma import upgma
from nj import neighbor_joining


def get_distances() -> ndarray:
    # Distances are based on the example
    # "Dendrogram of the BLOSUM62 matrix"
    # with the small modification M[i,j] += i+j
    # to reduce ambiguity in the tree construction.
    
    # Read file manually instead of using np.loadtxt with dtype parameter
    distances_list: List[List[int]] = []
    with open("../data/distances.txt", "r") as file:
        for line in file:
            line = line.strip()
            if line:
                row: List[int] = [int(x) for x in line.split()]
                distances_list.append(row)
    
    # Convert to numpy array
    n: int = len(distances_list)
    m: int = len(distances_list[0]) if n > 0 else 0
    result = zeros((n, m), dtype=int32)
    
    for i in range(n):
        for j in range(m):
            result[i, j] = int32(distances_list[i][j])
    
    return result


def get_tree(distances: ndarray) -> Tree:
    return upgma(distances)


def get_upgma_newick() -> str:
    # Newick notation of the tree created from 'distances.txt',
    # created via DendroUPGMA
    with open("../data/newick_upgma.txt", "r") as file:
        newick: str = file.read().strip()
    return newick


def test_upgma(tree: Tree, upgma_newick: str) -> None:
    """
    Compare the results of `upgma()` with DendroUPGMA.
    """
    ref_tree: Tree = Tree.from_newick(upgma_newick)
    # Cannot apply direct tree equality assertion because the distance
    # might not be exactly equal due to floating point rounding errors
    for i in range(len(tree)):
        for j in range(len(tree)):
            # Check for equal distances and equal topologies
            tree_dist: float = tree.get_distance(i, j)
            ref_dist: float = ref_tree.get_distance(i, j)
            
            # Manual approximation check with tolerance 1e-3
            if abs(tree_dist - ref_dist) >= 1e-3:
                raise AssertionError(
                    f"Distance mismatch at ({i}, {j}): {tree_dist} vs {ref_dist}"
                )
            
            tree_topo: float = tree.get_distance(i, j, topological=True)
            ref_topo: float = ref_tree.get_distance(i, j, topological=True)
            
            if tree_topo != ref_topo:
                raise AssertionError(
                    f"Topological distance mismatch at ({i}, {j}): {tree_topo} vs {ref_topo}"
                )


def test_neighbor_joining() -> None:
    """
    Compare the results of `neighbor_join()` with a known tree.
    """
    # Create distance matrix manually
    dist = zeros((6, 6), dtype=float32)
    
    dist[0, 0] = 0.0
    dist[0, 1] = 5.0
    dist[0, 2] = 4.0
    dist[0, 3] = 7.0
    dist[0, 4] = 6.0
    dist[0, 5] = 8.0
    
    dist[1, 0] = 5.0
    dist[1, 1] = 0.0
    dist[1, 2] = 7.0
    dist[1, 3] = 10.0
    dist[1, 4] = 9.0
    dist[1, 5] = 11.0
    
    dist[2, 0] = 4.0
    dist[2, 1] = 7.0
    dist[2, 2] = 0.0
    dist[2, 3] = 7.0
    dist[2, 4] = 6.0
    dist[2, 5] = 8.0
    
    dist[3, 0] = 7.0
    dist[3, 1] = 10.0
    dist[3, 2] = 7.0
    dist[3, 3] = 0.0
    dist[3, 4] = 5.0
    dist[3, 5] = 9.0
    
    dist[4, 0] = 6.0
    dist[4, 1] = 9.0
    dist[4, 2] = 6.0
    dist[4, 3] = 5.0
    dist[4, 4] = 0.0
    dist[4, 5] = 8.0
    
    dist[5, 0] = 8.0
    dist[5, 1] = 11.0
    dist[5, 2] = 8.0
    dist[5, 3] = 9.0
    dist[5, 4] = 8.0
    dist[5, 5] = 0.0

    ref_tree: Tree = Tree(
        TreeNode(
            [
                TreeNode(
                    [
                        TreeNode(
                            [
                                TreeNode(index=0),
                                TreeNode(index=1),
                            ],
                            [1.0, 4.0],
                        ),
                        TreeNode(index=2),
                    ],
                    [1.0, 2.0],
                ),
                TreeNode(
                    [
                        TreeNode(index=3),
                        TreeNode(index=4),
                    ],
                    [3.0, 2.0],
                ),
                TreeNode(index=5),
            ],
            [1.0, 1.0, 5.0],
        )
    )

    test_tree: Tree = neighbor_joining(dist)

    if not test_tree == ref_tree:
        raise AssertionError("Neighbor joining tree does not match reference tree")


def test_distances(tree: Tree) -> None:
    # Tree is created via UPGMA
    # -> The distances to root should be equal for all leaf nodes
    dist: float = tree.root.distance_to(tree.leaves[0])
    for leaf in tree.leaves:
        leaf_dist: float = leaf.distance_to(tree.root)
        if leaf_dist != dist:
            raise AssertionError(
                f"Distance to root not equal for all leaves: {leaf_dist} vs {dist}"
            )
    
    # Example topological distances
    topo_dist_1: float = tree.get_distance(0, 19, True)
    if topo_dist_1 != 9.0:
        raise AssertionError(
            f"Topological distance (0, 19) should be 9, got {topo_dist_1}"
        )
    
    topo_dist_2: float = tree.get_distance(4, 2, True)
    if topo_dist_2 != 10.0:
        raise AssertionError(
            f"Topological distance (4, 2) should be 10, got {topo_dist_2}"
        )


def main() -> None:
    import time
    
    distances_data: ndarray = get_distances()
    upgma_newick_data: str = get_upgma_newick()
    tree_data: Tree = upgma(distances_data)
    
    start: float = time.time()
    
    test_distances(tree_data)
    test_neighbor_joining()
    test_upgma(tree_data, upgma_newick_data)
    
    elapsed: float = (time.time() - start) * 1000
    
    print("codon         " + str(int(elapsed)) + "ms")


if __name__ == "__main__":
    main()