"""
Bio.motifs.minimal - Codon Implementation

Port of BioPython's MEME minimal motif format parser to Codon for high-performance
computational biology applications.

Key Codon Adaptations from Original BioPython:
- Replaced file handle iteration with explicit line reading
- Simplified string parsing without complex regex or advanced string methods
- Used explicit type annotations (List, Dict, Optional) for static compilation
- Removed Bio.motifs dependency - implemented minimal Motif class locally
- Simplified exception handling (generic Exception instead of ValueError)
- Replaced list comprehensions with explicit loops where needed
- Used manual string splitting and parsing instead of complex operations
- Removed doctest integration and advanced BioPython features
- Implemented minimal file I/O without BioPython's handle management

Classes Implemented:
- Record: Container for MEME minimal format results
- Motif: Minimal motif representation with counts and metadata
- FrequencyPositionMatrix: Basic count matrix (subset needed for minimal format)

Performance optimizations maintain API compatibility while enabling static compilation
for parsing MEME minimal format files in computational biology pipelines.
"""

from matrix import FrequencyPositionMatrix
from typing import Optional, Tuple

class Motif:
    """Minimal motif class for MEME format compatibility."""
    
    def __init__(self, alphabet: str, counts: Dict[str, List[int]]):
        """Initialize motif with alphabet and count matrix."""
        self.alphabet = alphabet
        self.counts = FrequencyPositionMatrix(alphabet, counts)
        self.background = Dict[str, float]()
        self.length = self.counts.length
        self.num_occurrences = 0
        self.evalue = 0.0
        self.name = ""


class Record:
    """Class for holding the results of a minimal MEME run."""
    
    def __init__(self):
        """Initialize record class values."""
        self.version = ""
        self.datafile = ""
        self.command = ""
        self.alphabet = ""
        self.background = Dict[str, float]()
        self.sequences = List[str]()
        self._motifs = List[Motif]()
        self._motif_names = Dict[str, int]()
    
    def append(self, motif: Motif):
        """Add a motif to the record."""
        index = len(self._motifs)
        self._motifs.append(motif)
        if motif.name:
            self._motif_names[motif.name] = index
    
    def __len__(self) -> int:
        """Return number of motifs in record."""
        return len(self._motifs)
    
    def __getitem__(self, key):
        """Return the motif of index key."""
        if isinstance(key, str):
            if key in self._motif_names:
                index = self._motif_names[key]
                return self._motifs[index]
            else:
                raise KeyError("Motif '" + key + "' not found")
        elif isinstance(key, int):
            return self._motifs[key]
        else:
            raise TypeError("Key must be string or int")
    
    def __iter__(self):
        """Iterate over motifs in record."""
        return iter(self._motifs)


def read(handle) -> Record:
    """Parse the text output of the MEME program into a Record object.
    
    Args:
        handle: File handle or list of strings containing MEME minimal format
        
    Returns:
        Record object containing parsed motifs
    """
    motif_number = 0
    record = Record()
    
    # Convert handle to list of lines if it's a file-like object
    if hasattr(handle, 'readlines'):
        lines = handle.readlines()
    elif hasattr(handle, '__iter__'):
        lines = list(handle)
    else:
        raise TypeError("Handle must be file-like or iterable")
    
    line_index = 0
    
    # Read version
    line_index = _read_version(record, lines, line_index)
    
    # Read alphabet
    line_index = _read_alphabet(record, lines, line_index)
    
    # Read background
    line_index = _read_background(record, lines, line_index)
    
    # Read motifs
    while line_index < len(lines):
        # Find next motif
        while line_index < len(lines):
            line = lines[line_index].strip()
            if line.startswith("MOTIF"):
                break
            line_index += 1
        else:
            # No more motifs found
            break
        
        # Parse motif name
        parts = line.split()
        if len(parts) < 2:
            raise Exception("Invalid MOTIF line format: " + line)
        name = parts[1]
        motif_number += 1
        line_index += 1
        
        # Read motif statistics and matrix
        length, num_occurrences, evalue, line_index = _read_motif_statistics(lines, line_index)
        counts, line_index = _read_lpm(record, lines, line_index, length, num_occurrences)
        
        # Create motif
        motif = Motif(record.alphabet, counts)
        motif.background = record.background
        motif.length = motif.counts.length
        motif.num_occurrences = num_occurrences
        motif.evalue = evalue
        motif.name = name
        record.append(motif)
    
    return record


def _read_version(record: Record, lines: List[str], start_index: int) -> int:
    """Read MEME version (PRIVATE)."""
    line_index = start_index
    while line_index < len(lines):
        line = lines[line_index].strip()
        if line.startswith("MEME version"):
            parts = line.split()
            if len(parts) >= 3:
                record.version = parts[2]
            return line_index + 1
        line_index += 1
    
    raise Exception("Improper input file. File should contain a line starting with 'MEME version'")


def _read_alphabet(record: Record, lines: List[str], start_index: int) -> int:
    """Read alphabet (PRIVATE)."""
    line_index = start_index
    while line_index < len(lines):
        line = lines[line_index].strip()
        if line.startswith("ALPHABET"):
            if not line.startswith("ALPHABET= "):
                raise Exception("Line does not start with 'ALPHABET= ':\n" + line)
            
            alphabet_part = line.replace("ALPHABET= ", "")
            if alphabet_part == "ACGT":
                record.alphabet = "ACGT"
            elif alphabet_part == "ACGU":
                record.alphabet = "ACGU"
            else:
                raise Exception("Only parsing of DNA and RNA motifs is implemented")
            
            return line_index + 1
        line_index += 1
    
    raise Exception("Unexpected end of stream: Expected to find line starting with 'ALPHABET'")


def _read_background(record: Record, lines: List[str], start_index: int) -> int:
    """Read background letter frequencies (PRIVATE)."""
    line_index = start_index
    
    # Find background frequencies line
    while line_index < len(lines):
        line = lines[line_index].strip()
        if line.startswith("Background letter frequencies"):
            line_index += 1
            break
        line_index += 1
    else:
        raise Exception("Improper input file. File should contain a line starting with 'Background letter frequencies'")
    
    # Read frequency lines
    background_freqs = List[float]()
    while line_index < len(lines):
        line = lines[line_index].strip()
        if not line:
            # Empty line indicates end of background section
            break
        
        parts = line.split(" ")
        for i in range(len(parts)):
            if i % 2 == 1:  # Every second element is a frequency
                try:
                    freq = float(parts[i])
                    background_freqs.append(freq)
                except ValueError:
                    pass
        line_index += 1
    
    if len(background_freqs) == 0:
        raise Exception("Unexpected end of stream: Expected to find background frequencies")
    
    # Map frequencies to alphabet letters
    for i in range(min(len(record.alphabet), len(background_freqs))):
        letter = record.alphabet[i]
        record.background[letter] = background_freqs[i]
    
    return line_index + 1


def _read_motif_statistics(lines: List[str], start_index: int) -> Tuple[Optional[int], int, float, int]:
    """Read motif statistics (PRIVATE)."""
    line_index = start_index
    
    # Find letter-probability matrix line
    while line_index < len(lines):
        line = lines[line_index].strip()
        if line.startswith("letter-probability matrix:"):
            break
        line_index += 1
    else:
        raise Exception("Expected to find 'letter-probability matrix:' line")
    
    line = lines[line_index]
    
    # Parse statistics from the line
    # Default values
    length = None
    num_occurrences = 20
    evalue = 0.0
    
    # Extract nsites
    if "nsites=" in line:
        parts = line.split("nsites=")
        if len(parts) > 1:
            nsites_part = parts[1].split()[0]
            try:
                num_occurrences = int(nsites_part)
            except ValueError:
                num_occurrences = 20
    
    # Extract length (w=)
    if "w=" in line:
        parts = line.split("w=")
        if len(parts) > 1:
            w_part = parts[1].split()[0]
            try:
                length = int(w_part)
            except ValueError:
                length = None
    
    # Extract E-value
    if "E=" in line:
        parts = line.split("E=")
        if len(parts) > 1:
            e_part = parts[1].split()[0]
            try:
                evalue = float(e_part)
            except ValueError:
                evalue = 0.0
    
    return length, num_occurrences, evalue, line_index + 1


def _read_lpm(record: Record, lines: List[str], start_index: int, 
             length: Optional[int], num_occurrences: int) -> Tuple[Dict[str, List[int]], int]:
    """Read letter probability matrix (PRIVATE)."""
    line_index = start_index
    counts = Dict[str, List[int]]()
    
    # Initialize count lists
    for letter in record.alphabet:
        counts[letter] = List[int]()
    
    positions_read = 0
    while line_index < len(lines):
        line = lines[line_index].strip()
        if not line:
            # Empty line - check if we have expected length
            if length is not None and positions_read < length:
                line_index += 1
                continue
            else:
                break
        
        # Try to parse as frequency line
        parts = line.split()
        if len(parts) != 4:
            # Not a frequency line
            break
        
        try:
            freqs = [float(part) for part in parts]
        except ValueError:
            # Not all parts are numbers
            break
        
        # Convert frequencies to counts and add to matrix
        for i, letter in enumerate(record.alphabet):
            if i < len(freqs):
                count = round(freqs[i] * num_occurrences)
                counts[letter].append(count)
        
        positions_read += 1
        line_index += 1
        
        # Stop if we've read the expected length
        if length is not None and positions_read >= length:
            break
    
    return counts, line_index